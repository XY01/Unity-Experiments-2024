// VectorFieldComputeShader.compute

#pragma kernel InitVectorfield

// The number of threads per group in each dimension
#define THREAD_X 8
#define THREAD_Y 8
#define THREAD_Z 8
#define PI 3.1416

// The buffer to write the vector field to
RWStructuredBuffer<float4> VectorfieldBuffer;

// The dimensions of the vector field
uint3 Dimensions;

[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]
void InitVectorfield (uint3 id : SV_DispatchThreadID)
{
    // Ensure we do not write outside the bounds of the buffer
    uint index = id.x + id.y * Dimensions.x + id.z * Dimensions.x * Dimensions.y;

    if(id.x >= Dimensions.x || id.y >= Dimensions.y || id.z >= Dimensions.z)
    {
        return;
    }    

    float normalizedX = id.x / max(((float)Dimensions.x - 1.0), 1.0);
    float normalizedY = id.y / max(((float)Dimensions.y - 1.0), 1.0);
    float normalizedZ = id.z / max(((float)Dimensions.z - 1.0), 1.0);

    float3 position = float3(id.x, id.y, id.z);   
    float3 vec = float3(-1 + (normalizedX * 2),-1 + (normalizedY * 2), -1 + (normalizedZ * 2));
   
    
    // Write the result to the buffer
    VectorfieldBuffer[index] = float4(vec, 0);
}
